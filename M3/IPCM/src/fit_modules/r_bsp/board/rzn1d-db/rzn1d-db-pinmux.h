/*
 * This file was autogenerated
 * DO NOT EDIT
 * (C) 2015-2019 Renesas Electronics Europe, LTD
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef __RZN1_BOARD_PINMUX_H__
#define __RZN1_BOARD_PINMUX_H__
/*
 * AUTOGENERATED DO NOT EDIT
 *
 * Pin Mux header for BMD development RZN1D DB+EB 20-02-18 UART7 and 8 + SPI5 included+USB+LCD
 * This file only sets the pin function by default.
 *
 * You can override the default mux pull-up/down and drive by
 * defining the following macros in the board file before
 * including this.
 */

#ifndef RZN1_MUX_DEFAULT
#define RZN1_MUX_DEFAULT RZN1_MUX
#endif

#include "renesas/pinctrl-rzn1.h"

#ifndef RZN1_MUX_CAN
#define RZN1_MUX_CAN RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_CAN0
#define RZN1_MUX_CAN0 RZN1_MUX_CAN
#endif
#ifndef RZN1_MUX_CAN1
#define RZN1_MUX_CAN1 RZN1_MUX_CAN
#endif
#ifndef RZN1_MUX_ETH
#define RZN1_MUX_ETH RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_ETH0
#define RZN1_MUX_ETH0 RZN1_MUX_ETH
#endif
#ifndef RZN1_MUX_ETH1
#define RZN1_MUX_ETH1 RZN1_MUX_ETH
#endif
#ifndef RZN1_MUX_ETH2
#define RZN1_MUX_ETH2 RZN1_MUX_ETH
#endif
#ifndef RZN1_MUX_ETH3
#define RZN1_MUX_ETH3 RZN1_MUX_ETH
#endif
#ifndef RZN1_MUX_ETH4
#define RZN1_MUX_ETH4 RZN1_MUX_ETH
#endif
#ifndef RZN1_MUX_GPIO
#define RZN1_MUX_GPIO RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_GPIO0
#define RZN1_MUX_GPIO0 RZN1_MUX_GPIO
#endif
#ifndef RZN1_MUX_GPIO1
#define RZN1_MUX_GPIO1 RZN1_MUX_GPIO
#endif
#ifndef RZN1_MUX_GPIO2
#define RZN1_MUX_GPIO2 RZN1_MUX_GPIO
#endif
#ifndef RZN1_MUX_I2C
#define RZN1_MUX_I2C RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_I2C1
#define RZN1_MUX_I2C1 RZN1_MUX_I2C
#endif
#ifndef RZN1_MUX_LCD
#define RZN1_MUX_LCD RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_MDIO
#define RZN1_MUX_MDIO RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_MDIO0
#define RZN1_MUX_MDIO0 RZN1_MUX_MDIO
#endif
#ifndef RZN1_MUX_MDIO1
#define RZN1_MUX_MDIO1 RZN1_MUX_MDIO
#endif
#ifndef RZN1_MUX_QSPI
#define RZN1_MUX_QSPI RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_QSPI0
#define RZN1_MUX_QSPI0 RZN1_MUX_QSPI
#endif
#ifndef RZN1_MUX_REFCLK
#define RZN1_MUX_REFCLK RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_SDIO
#define RZN1_MUX_SDIO RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_SDIO0
#define RZN1_MUX_SDIO0 RZN1_MUX_SDIO
#endif
#ifndef RZN1_MUX_SPI
#define RZN1_MUX_SPI RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_SPI4
#define RZN1_MUX_SPI4 RZN1_MUX_SPI
#endif
#ifndef RZN1_MUX_SWITCH
#define RZN1_MUX_SWITCH RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_UART
#define RZN1_MUX_UART RZN1_MUX_DEFAULT
#endif
#ifndef RZN1_MUX_UART0
#define RZN1_MUX_UART0 RZN1_MUX_UART
#endif
#ifndef RZN1_MUX_UART1
#define RZN1_MUX_UART1 RZN1_MUX_UART
#endif
#ifndef RZN1_MUX_UART2
#define RZN1_MUX_UART2 RZN1_MUX_UART
#endif
#ifndef RZN1_MUX_UART3
#define RZN1_MUX_UART3 RZN1_MUX_UART
#endif
#ifndef RZN1_MUX_UART6
#define RZN1_MUX_UART6 RZN1_MUX_UART
#endif
#ifndef RZN1_MUX_UART7
#define RZN1_MUX_UART7 RZN1_MUX_UART
#endif
#ifndef RZN1_MUX_USB
#define RZN1_MUX_USB RZN1_MUX_DEFAULT
#endif

#define RZN1_MUX_PERIPH_BIT	24

/*
 * These numbers are arbitrary and do not correspond to anything
 * on the hardware, they are for the application convenience only
 * and *will* change if the pinmux is regenerated by the Webapp.
 */
enum {
	RZN1_P_CAN0 = 0, RZN1_P_CAN1, RZN1_P_ETH0, RZN1_P_ETH1, RZN1_P_ETH2, RZN1_P_ETH3,
	RZN1_P_ETH4, RZN1_P_GPIO0, RZN1_P_GPIO1, RZN1_P_GPIO2, RZN1_P_I2C1, RZN1_P_LCD,
	RZN1_P_MDIO0, RZN1_P_MDIO1, RZN1_P_QSPI0, RZN1_P_REFCLK, RZN1_P_SDIO0, RZN1_P_SPI4,
	RZN1_P_SWITCH, RZN1_P_UART0, RZN1_P_UART1, RZN1_P_UART2, RZN1_P_UART3, RZN1_P_UART6,
	RZN1_P_UART7, RZN1_P_USB,
};

/*
 * A peripheral number is also encoded in these constants to
 * help parsing in case your code wishes to do pinmux selectively
 */
#define _RZP(_P, _M) ((_M) | (RZN1_##_P << RZN1_MUX_PERIPH_BIT))

static const uint32_t rzn1_pinmux_map[] = {
	_RZP(P_CAN0, RZN1_MUX_CAN0(162, CAN)),			/* CAN0_TXD */
	_RZP(P_CAN0, RZN1_MUX_CAN0(163, CAN)),			/* CAN0_RXD */
	_RZP(P_CAN1, RZN1_MUX_CAN1(109, CAN)),			/* CAN1_TXD */
	_RZP(P_CAN1, RZN1_MUX_CAN1(110, CAN)),			/* CAN1_RXD */
	_RZP(P_ETH0, RZN1_MUX_ETH0(1, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[0] */
	_RZP(P_ETH0, RZN1_MUX_ETH0(2, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXD[1] */
	_RZP(P_ETH0, RZN1_MUX_ETH0(5, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_TXEN */
	_RZP(P_ETH0, RZN1_MUX_ETH0(6, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXCLK */
	_RZP(P_ETH0, RZN1_MUX_ETH0(7, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[0] */
	_RZP(P_ETH0, RZN1_MUX_ETH0(8, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXD[1] */
	_RZP(P_ETH0, RZN1_MUX_ETH0(11, CLK_ETH_MII_RGMII_RMII)),	/* ETH0_RXDV */
	_RZP(P_ETH1, RZN1_MUX_ETH1(13, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[0] */
	_RZP(P_ETH1, RZN1_MUX_ETH1(14, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXD[1] */
	_RZP(P_ETH1, RZN1_MUX_ETH1(17, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_TXEN */
	_RZP(P_ETH1, RZN1_MUX_ETH1(18, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXCLK */
	_RZP(P_ETH1, RZN1_MUX_ETH1(19, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[0] */
	_RZP(P_ETH1, RZN1_MUX_ETH1(20, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXD[1] */
	_RZP(P_ETH1, RZN1_MUX_ETH1(23, CLK_ETH_MII_RGMII_RMII)),	/* ETH1_RXDV */
	_RZP(P_ETH2, RZN1_MUX_ETH2(25, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[0] */
	_RZP(P_ETH2, RZN1_MUX_ETH2(26, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXD[1] */
	_RZP(P_ETH2, RZN1_MUX_ETH2(29, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_TXEN */
	_RZP(P_ETH2, RZN1_MUX_ETH2(30, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXCLK */
	_RZP(P_ETH2, RZN1_MUX_ETH2(31, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[0] */
	_RZP(P_ETH2, RZN1_MUX_ETH2(32, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXD[1] */
	_RZP(P_ETH2, RZN1_MUX_ETH2(35, CLK_ETH_MII_RGMII_RMII)),	/* ETH2_RXDV */
	_RZP(P_ETH3, RZN1_MUX_ETH3(37, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[0] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(38, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXD[1] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(41, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_TXEN */
	_RZP(P_ETH3, RZN1_MUX_ETH3(42, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXCLK */
	_RZP(P_ETH3, RZN1_MUX_ETH3(43, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[0] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(44, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXD[1] */
	_RZP(P_ETH3, RZN1_MUX_ETH3(47, CLK_ETH_MII_RGMII_RMII)),	/* ETH3_RXDV */
	_RZP(P_ETH4, RZN1_MUX_ETH4(49, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[0] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(50, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXD[1] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(53, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_TXEN */
	_RZP(P_ETH4, RZN1_MUX_ETH4(54, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXCLK */
	_RZP(P_ETH4, RZN1_MUX_ETH4(55, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[0] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(56, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXD[1] */
	_RZP(P_ETH4, RZN1_MUX_ETH4(59, CLK_ETH_MII_RGMII_RMII)),	/* ETH4_RXDV */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(0, GPIO)),			/* GPIO0A[0] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(3, GPIO)),			/* GPIO0A[1] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(4, GPIO)),			/* GPIO0A[2] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(9, GPIO)),			/* GPIO0A[3] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(10, GPIO)),		/* GPIO0A[4] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(12, GPIO)),		/* GPIO0A[5] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(15, GPIO)),		/* GPIO0A[6] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(16, GPIO)),		/* GPIO0A[7] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(21, GPIO)),		/* GPIO0A[8] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(22, GPIO)),		/* GPIO0A[9] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(24, GPIO)),		/* GPIO0A[10] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(27, GPIO)),		/* GPIO0A[11] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(28, GPIO)),		/* GPIO0A[12] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(33, GPIO)),		/* GPIO0A[13] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(34, GPIO)),		/* GPIO0A[14] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(36, GPIO)),		/* GPIO0A[15] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(39, GPIO)),		/* GPIO0A[16] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(40, GPIO)),		/* GPIO0A[17] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(45, GPIO)),		/* GPIO0A[18] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(46, GPIO)),		/* GPIO0A[19] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(48, GPIO)),		/* GPIO0A[20] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(51, GPIO)),		/* GPIO0A[21] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(52, GPIO)),		/* GPIO0A[22] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(57, GPIO)),		/* GPIO0A[23] */
	_RZP(P_GPIO0, RZN1_MUX_GPIO0(58, GPIO)),		/* GPIO0A[24] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(83, GPIO)),		/* GPIO1B[14] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(86, GPIO)),		/* GPIO1B[17] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(87, GPIO)),		/* GPIO1B[18] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(88, GPIO)),		/* GPIO1B[19] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(89, GPIO)),		/* GPIO1B[20] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(90, GPIO)),		/* GPIO1B[21] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(91, GPIO)),		/* GPIO1B[22] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(92, GPIO)),		/* GPIO1B[23] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(93, GPIO)),		/* GPIO1B[24] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(94, GPIO)),		/* GPIO1B[25] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(107, GPIO)),		/* GPIO1A[17] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(108, GPIO)),		/* GPIO1A[18] */
	_RZP(P_GPIO1, RZN1_MUX_PUP_4MA(112, GPIO)),		/* GPIO1A[22] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(113, GPIO)),		/* GPIO1A[23] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(117, GPIO)),		/* GPIO1A[27] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(118, GPIO)),		/* GPIO1A[28] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(154, GPIO)),		/* GPIO1B[30] */
	_RZP(P_GPIO1, RZN1_MUX_GPIO1(155, GPIO)),		/* GPIO1B[31] */
	_RZP(P_GPIO2, RZN1_MUX_GPIO2(125, GPIO)),		/* GPIO2A[3] */
	_RZP(P_GPIO2, RZN1_MUX_GPIO2(126, GPIO)),		/* GPIO2A[4] */
	_RZP(P_GPIO2, RZN1_MUX_GPIO2(146, GPIO)),		/* GPIO2A[24] */
	_RZP(P_GPIO2, RZN1_MUX_GPIO2(148, GPIO)),		/* GPIO2A[26] */
	_RZP(P_GPIO2, RZN1_MUX_GPIO2(166, GPIO)),		/* GPIO2B[6] */
	_RZP(P_GPIO2, RZN1_MUX_GPIO2(167, GPIO)),		/* GPIO2B[7] */
	_RZP(P_I2C1, RZN1_MUX_I2C1(115, I2C)),			/* I2C1_SCL */
	_RZP(P_I2C1, RZN1_MUX_I2C1(116, I2C)),			/* I2C1_SDA */
	_RZP(P_LCD, RZN1_MUX_LCD(62, LCD)),			/* LCD_R[1] */
	_RZP(P_LCD, RZN1_MUX_LCD(63, LCD)),			/* LCD_G[1] */
	_RZP(P_LCD, RZN1_MUX_LCD(64, LCD)),			/* LCD_B[1] */
	_RZP(P_LCD, RZN1_MUX_LCD(65, LCD)),			/* LCD_R[2] */
	_RZP(P_LCD, RZN1_MUX_LCD(66, LCD)),			/* LCD_G[2] */
	_RZP(P_LCD, RZN1_MUX_LCD(67, LCD)),			/* LCD_B[2] */
	_RZP(P_LCD, RZN1_MUX_LCD(68, LCD)),			/* LCD_R[3] */
	_RZP(P_LCD, RZN1_MUX_LCD(69, LCD)),			/* LCD_G[3] */
	_RZP(P_LCD, RZN1_MUX_LCD(70, LCD)),			/* LCD_B[3] */
	_RZP(P_LCD, RZN1_MUX_LCD(71, LCD)),			/* LCD_R[4] */
	_RZP(P_LCD, RZN1_MUX_LCD(72, LCD)),			/* LCD_G[4] */
	_RZP(P_LCD, RZN1_MUX_LCD(73, LCD)),			/* LCD_B[4] */
	_RZP(P_LCD, RZN1_MUX_LCD(127, LCD)),			/* LCD_PWM[0] */
	_RZP(P_LCD, RZN1_MUX_LCD(128, LCD)),			/* LCD_PCLK */
	_RZP(P_LCD, RZN1_MUX_LCD(129, LCD)),			/* LCD_HSYNC */
	_RZP(P_LCD, RZN1_MUX_LCD(130, LCD)),			/* LCD_VSYNC */
	_RZP(P_LCD, RZN1_MUX_LCD(131, LCD)),			/* LCD_DE */
	_RZP(P_LCD, RZN1_MUX_LCD(132, LCD)),			/* LCD_PE */
	_RZP(P_LCD, RZN1_MUX_LCD(133, LCD)),			/* LCD_PWM[1] */
	_RZP(P_LCD, RZN1_MUX_LCD(134, LCD)),			/* LCD_R[5] */
	_RZP(P_LCD, RZN1_MUX_LCD(135, LCD)),			/* LCD_R[0] */
	_RZP(P_LCD, RZN1_MUX_LCD(136, LCD)),			/* LCD_G[0] */
	_RZP(P_LCD, RZN1_MUX_LCD(137, LCD)),			/* LCD_B[0] */
	_RZP(P_LCD, RZN1_MUX_LCD(138, LCD)),			/* LCD_R[6] */
	_RZP(P_LCD, RZN1_MUX_LCD(139, LCD)),			/* LCD_G[6] */
	_RZP(P_LCD, RZN1_MUX_LCD(140, LCD)),			/* LCD_B[6] */
	_RZP(P_LCD, RZN1_MUX_LCD(141, LCD)),			/* LCD_R[7] */
	_RZP(P_LCD, RZN1_MUX_LCD(142, LCD)),			/* LCD_G[7] */
	_RZP(P_LCD, RZN1_MUX_LCD(143, LCD)),			/* LCD_B[7] */
	_RZP(P_LCD, RZN1_MUX_LCD(144, LCD)),			/* LCD_G[5] */
	_RZP(P_LCD, RZN1_MUX_LCD(145, LCD)),			/* LCD_B[5] */
	_RZP(P_MDIO0, RZN1_MUX_MDIO0(150, ETH_MDIO)),		/* MDIO0_MDC */
	_RZP(P_MDIO0, RZN1_MUX_MDIO0(151, ETH_MDIO)),		/* MDIO0_MDIO */
	/*
	 * 170 and 171 are not hardware PL_GPIOs, they are used to
	 * set the MDIO mux mode in a similar fashion as all the other
	 * pinmux functions. See the renesas/rzn1_pinmux.c file.
	 */
	_RZP(P_MDIO0, RZN1_MUX_MDIO0(170, MDIO_MUX_MAC1)),	/* MDIO0_MUX_MAC1 */
	_RZP(P_MDIO1, RZN1_MUX_MDIO1(152, ETH_MDIO)),		/* MDIO1_MDC */
	_RZP(P_MDIO1, RZN1_MUX_MDIO1(153, ETH_MDIO)),		/* MDIO1_MDIO */
	_RZP(P_MDIO1, RZN1_MUX_MDIO1(171, MDIO_MUX_MAC1)),	/* MDIO1_MUX_MAC1 */
	_RZP(P_QSPI0, RZN1_MUX_PUP_6MA(74, QSPI)),		/* QSPI0_CS_N[0] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(75, QSPI)),		/* QSPI0_IO[3] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(76, QSPI)),		/* QSPI0_IO[2] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(77, QSPI)),		/* QSPI0_IO[1] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(78, QSPI)),		/* QSPI0_IO[0] */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(79, QSPI)),		/* QSPI0_CLK */
	_RZP(P_QSPI0, RZN1_MUX_QSPI0(149, QSPI)),		/* QSPI0_CS_N[2] */
	_RZP(P_REFCLK, RZN1_MUX_REFCLK(60, CLK_ETH_MII_RGMII_RMII)),	/* REFCLK_RGMII */
	_RZP(P_REFCLK, RZN1_MUX_REFCLK(61, CLK_ETH_NAND)),	/* REFCLK_MII[1] */
	_RZP(P_SDIO0, RZN1_MUX_SDIO0(95, SDIO)),		/* SDIO0_CMD */
	_RZP(P_SDIO0, RZN1_MUX_12MA(96, SDIO)),			/* SDIO0_CLK */
	_RZP(P_SDIO0, RZN1_MUX_SDIO0(97, SDIO)),		/* SDIO0_IO[0] */
	_RZP(P_SDIO0, RZN1_MUX_SDIO0(98, SDIO)),		/* SDIO0_IO[1] */
	_RZP(P_SDIO0, RZN1_MUX_SDIO0(99, SDIO)),		/* SDIO0_IO[2] */
	_RZP(P_SDIO0, RZN1_MUX_SDIO0(100, SDIO)),		/* SDIO0_IO[3] */
	_RZP(P_SDIO0, RZN1_MUX_SDIO0(101, SDIO_E)),		/* SDIO0_CD_N */
	_RZP(P_SDIO0, RZN1_MUX_SDIO0(102, SDIO_E)),		/* SDIO0_WP */
	_RZP(P_SPI4, RZN1_MUX_SPI4(156, SPI4_S)),		/* SPI4_CLK */
	_RZP(P_SPI4, RZN1_MUX_SPI4(157, SPI4_S)),		/* SPI4_MOSI */
	_RZP(P_SPI4, RZN1_MUX_SPI4(158, SPI4_S)),		/* SPI4_MISO */
	_RZP(P_SPI4, RZN1_MUX_SPI4(159, SPI4_S)),		/* SPI4_SS_N */
	_RZP(P_SWITCH, RZN1_MUX_SWITCH(80, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[5] */
	_RZP(P_SWITCH, RZN1_MUX_SWITCH(81, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[4] */
	_RZP(P_SWITCH, RZN1_MUX_SWITCH(82, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[3] */
	_RZP(P_SWITCH, RZN1_MUX_SWITCH(114, MAC_MTIP_SWITCH)),	/* SWITCH_MII_LINK[2] */
	_RZP(P_UART0, RZN1_MUX_UART0(103, UART0_I)),		/* UART0_TXD */
	_RZP(P_UART0, RZN1_MUX_UART0(104, UART0_I)),		/* UART0_RXD */
	_RZP(P_UART1, RZN1_MUX_UART1(160, UART1)),		/* UART1_TXD */
	_RZP(P_UART1, RZN1_MUX_UART1(161, UART1)),		/* UART1_RXD */
	_RZP(P_UART2, RZN1_MUX_UART2(105, UART2)),		/* UART2_TXD */
	_RZP(P_UART2, RZN1_MUX_UART2(106, UART2)),		/* UART2_RXD */
	_RZP(P_UART3, RZN1_MUX_UART3(123, UART3)),		/* UART3_TXD */
	_RZP(P_UART3, RZN1_MUX_UART3(124, UART3)),		/* UART3_RXD */
	_RZP(P_UART6, RZN1_MUX_UART6(164, UART6)),		/* UART6_TXD */
	_RZP(P_UART6, RZN1_MUX_UART6(165, UART6)),		/* UART6_RXD */
	_RZP(P_UART7, RZN1_MUX_UART7(168, UART7)),		/* UART7_TXD */
	_RZP(P_UART7, RZN1_MUX_UART7(169, UART7)),		/* UART7_RXD */
	_RZP(P_USB, RZN1_MUX_USB(119, USB)),			/* USB_PPON1 */
	_RZP(P_USB, RZN1_MUX_USB(120, USB)),			/* USB_OC1 */
	_RZP(P_USB, RZN1_MUX_USB(121, USB)),			/* USB_PPON2 */
	_RZP(P_USB, RZN1_MUX_USB(122, USB)),			/* USB_OC2 */
	0L, /* terminator */
};
/*
 * Sample function for setting the pinmux. Pass -1 for setting /all/
 * the pins, pass any of the RZN1_P_xxx for setting just that one set
 * returns the number of pins that have been set.
 * There is also a variant where you can pass multiple peripherals as
 * a bitmask.
 */
#ifdef USE_DEFAULT_PINMUX
/* Functions are marked 'unused' to prevent warnings on modern GCC */
#if defined(__GNUC__)
#define __unused __attribute__((unused))
#elif !defined(__unused)
#define __unused
#endif
static int rzn1_board_pinmux(int periph /* = -1 */) __unused;
static int rzn1_board_pinmux(int periph /* = -1 */) {
 int i, cnt = 0;
 for (i = 0; rzn1_pinmux_map[i]; i++)
  if (periph == -1 ||
      (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT) == (uint32_t)periph) {
       rzn1_pinmux_set(rzn1_pinmux_map[i]);
       cnt++;
 }
 return cnt;
}
static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) __unused;
static int rzn1_board_pinmux_mask(uint32_t periph_mask /* = -1 */) {
 int i, cnt = 0;
 for (i = 0; rzn1_pinmux_map[i]; i++)
  if (periph_mask & (1 << (rzn1_pinmux_map[i] >> RZN1_MUX_PERIPH_BIT))) {
   rzn1_pinmux_set(rzn1_pinmux_map[i]);
   cnt++;
  }
 return cnt;
}
#endif

/*
 * This is the compressed Renesas Pinmux Web App data structure; this is
 * used to allow uploading this file back into the web app, make some
 * more changes and generate/save the DTS again. It is not used by Linux
 * in any way.
 */
#ifdef JSON_PRESET
N4IgdghgtgpiBcIAKBLMACAsgVwB7oAsYIATGAJ3QDMB7SgIUwBF0yA3GAGxoAdYwALugBKALQByARhZN6AagCi9dACYADAFo1Kj
ZIAc6AKoBBYQBUA7OghgS6A3PQBlJAEkArOjQBjTtjIkcoZO8gAyAMJMIAA0IDwQ3gDWEADmcIgwACxqajFxFCg8ROQQnADOCADa
IOHGUnm14ip5CmYAEpIt7c2xrW0AzF1tmUPueQDibgDynbGTrlM9IPNTg7GuKuFLEVGxzAuzIPuLeQCKLq6HwgoAYuGhANJ5TkwH
z25jsU4A6q5m4W08iZzIdgWYlmC1iAwSNYmCLEDTGY9ECQiAALqxFI8FA0AD6kFgFXgwAAvlicTRiZVMhYAGySOnRfr9FR6STM1l
6FTRWkMgCcvPp6k5bPcor0TJZbIsEr0QrpKnFfJUUtZ/I5Kvl0v5/VF/MyCv6mvprP1sp12vVgpZ/RyRtlfP6Vrter52U5dvFtrU
TPdbvpmUNPptLMkak9kg5tskPPdgr57gjMeV9PcPJjFrD8sTqbp7jVrOj0oz0r1tpUhr5DIVis9Kkd9LpwZ1nrttcbdLpLpZbZbL
O9tr99IsAbpFn7/VD/Q9A/5Fsy/S7zMX45XS+1q5ti4syZ30Z3GZ35Z3wZ33p3Up3sv0altVslWclD7pob0u857457nDleiP+0cU
ANVBV+QTJU9AjTIIJNXc4wsXcA13KsELUVNd2HXdG13HNUITBDwxXSRF15fk2X5K9iIvYjKNpIjMm1AULQFbU9CTcs2LUKtw3zXk
eMwlQkL/Wl+XZIVRJ5RlnR/DlGUlWNcIsFRBQA9wc25EiGMrFDRyQmdmVfPRy0M4NDO9Qy/Ukdx+WVKyKKFCdYOgldFwPRcj0XE9
FzPRcL1XFz+gXRdN0Xbcgz3IM3Ocmcgy8oMXMyPzMivIMgoYhL8OFBzm05A1o3zbQDPYoquJK9CP1pAjeUVJdqsEx0apzGqE19NQ
c1ahNIP0hi72VY0lN5fqkO5ByjMG7scw3FT9BG9wp2NdFSSAA===
#endif

#endif /* __RZN1_BOARD_PINMUX_H__ */